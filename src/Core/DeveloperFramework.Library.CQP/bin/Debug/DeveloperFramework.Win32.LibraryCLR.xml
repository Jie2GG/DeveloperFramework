<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DeveloperFramework.Win32.LibraryCLR</name>
    </assembly>
    <members>
        <member name="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary">
            <summary>
            提供用于操作 (C/C++) 动态链接库的操作类
            </summary>
        </member>
        <member name="P:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.LibraryPath">
            <summary>
            获取当前加载动态链接库 (DLL) 的路径
            </summary>
        </member>
        <member name="P:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.LibraryDirectory">
            <summary>
            获取当前加载动态链接库 (DLL) 的目录
            </summary>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.#ctor(System.String)">
            <summary>
            初始化 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 类的新实例, 并加载指定的动态链接库 (DLL)
            </summary>
            <param name="libFileName">要加载的动态链接库 (DLL) 的路径</param>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.Finalize">
            <summary>
            释放 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 类所使用的资源
            </summary>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetResultCode">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 执行过程中的结果代码
            </summary>
            <returns>返回从操作系统底层获取的结果代码</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetResultMessage">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 执行过程中的详细信息
            </summary>
            <returns>返回从操作系统底层获取的详细执行信息</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.FunctionExist(System.String)">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 指定的函数指针是否存在
            </summary>
            <param name="funcName">函数名称</param>
            <returns>如果存在返回 <see langword="true"/>, 否则返回 <see langword="false"/></returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetFunction(System.String,System.Type)">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 指定函数指针, 并转换为 <see cref="T:System.Delegate"/>
            </summary>
            <param name="funcName">函数名称</param>
            <param name="funcType">函数类型, 该类型必须为非开放式泛型委托</param>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.ArgumentException">funcType 参数不是委托或泛型</exception>
            <exception cref="T:System.MissingMethodException">尝试访问未公开的函数</exception>
            <returns>可转换为适当的委托类型的委托实例</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetFunction``1(System.String)">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 指定的函数指针, 并转换为 <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TDelegate">要返回的委托的类型</typeparam>
            <param name="funcName">函数名称</param>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.ArgumentException">TDelegate 不是委托，或它是一个开放式泛型类型</exception>
            <exception cref="T:System.MissingMethodException">尝试访问未公开的函数</exception>
            <returns>指定委托类型的实例</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.InvokeFunction(System.Type,System.String,System.Object[])">
            <summary>
            调用当前 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 实例指定名称的函数
            </summary>
            <param name="funcType">符合方法的委托类型</param>
            <param name="funcName">寻找的函数入口名称</param>
            <param name="args">传入库函数的参数列表</param>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.ArgumentException">TDelegate 不是委托，或它是一个开放式泛型类型</exception>
            <exception cref="T:System.MissingMethodException">尝试访问未公开的函数</exception>
            <exception cref="T:System.MemberAccessException">调用方没有访问 （例如，如果该方法是私有的），委托所表示的方法。 - 或 - 数量、 顺序或中列出的参数类型 args 无效</exception>
            <exception cref="T:System.ArgumentException">委托所表示的方法被调用一个或多个不支持它的类</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象是 <see langword="null"/>。 - 或 - 一个封装的方法引发的异常</exception>
            <returns>返回动态库函数的返回值</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.InvokeFunction``1(System.String,System.Object[])">
            <summary>
            调用当前 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 实例指定名称的函数
            </summary>
            <typeparam name="TDelegate">与函数指针对应的委托类型, 该类型不允许是泛型</typeparam>
            <param name="funcName">寻找的函数入口名称</param>
            <param name="args">传入库函数的参数列表</param>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.ArgumentException">TDelegate 不是委托，或它是一个开放式泛型类型</exception>
            <exception cref="T:System.MissingMethodException">尝试访问未公开的函数</exception>
            <exception cref="T:System.MemberAccessException">调用方没有访问 （例如，如果该方法是私有的），委托所表示的方法。 - 或 - 数量、 顺序或中列出的参数类型 args 无效</exception>
            <exception cref="T:System.ArgumentException">委托所表示的方法被调用一个或多个不支持它的类</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">委托所表示的方法是实例方法，目标对象是 <see langword="null"/>。 - 或 - 一个封装的方法引发的异常</exception>
            <returns>返回动态库函数的返回值</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.Dispose">
            <summary>
            执行与释放或重置非托管资源关联的应用程序定义的任务
            </summary>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.Equals(DeveloperFramework.Win32.LibraryCLR.DynamicLibrary)">
            <summary>
            返回一个值，该值指示此实例是否等于指定的对象
            </summary>
            <param name="other">要与此示例比较的对象，或 <see langword="null"/></param>
            <returns>如果 <see langword="true"/> 是 other 的实例并且等于此实例的值，则为 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/>；否则为 <see langword="false"/></returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.Equals(System.Object)">
            <summary>
            返回一个值，该值指示此实例是否等于指定的对象
            </summary>
            <param name="obj">要与此示例比较的对象，或 <see langword="null"/></param>
            <returns>如果 <see langword="true"/> 是 obj 的实例并且等于此实例的值，则为 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/>；否则为 <see langword="false"/></returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetHashCode">
            <summary>
            返回此实例的哈希代码
            </summary>
            <returns>位有符号整数哈希代码</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.ToString">
            <summary>
            将当前 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 对象的数值转换为其等效字符串表示形式
            </summary>
            <returns>当前 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 对象的值的字符串表示形式</returns>
        </member>
        <member name="M:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary.GetFunctionPtr(System.String)">
            <summary>
            获取当前实例 <see cref="T:DeveloperFramework.Win32.LibraryCLR.DynamicLibrary"/> 指定的函数指针
            </summary>
            <param name="funcName">函数名称</param>
            <exception cref="T:System.MissingMethodException">尝试访问未公开的函数</exception>
            <returns>返回托管的函数指针</returns>
        </member>
    </members>
</doc>
